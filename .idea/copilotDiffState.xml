<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/ci.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/ci.yml" />
              <option name="updatedContent" value="name: CI&#10;&#10;on:&#10;  push:&#10;    branches: [ main, develop ]&#10;  pull_request:&#10;    branches: [ main ]&#10;&#10;env:&#10;  CARGO_TERM_COLOR: always&#10;&#10;jobs:&#10;  test:&#10;    name: Test&#10;    runs-on: ${{ matrix.os }}&#10;    strategy:&#10;      matrix:&#10;        os: [ubuntu-latest, windows-latest, macos-latest]&#10;        rust: [stable, beta]&#10;        exclude:&#10;          # 减少 CI 时间，只在 stable 版本测试所有平台&#10;          - os: windows-latest&#10;            rust: beta&#10;          - os: macos-latest&#10;            rust: beta&#10;&#10;    steps:&#10;    - uses: actions/checkout@v4&#10;&#10;    - name: Install Rust&#10;      uses: dtolnay/rust-toolchain@stable&#10;      with:&#10;        toolchain: ${{ matrix.rust }}&#10;&#10;    - name: Cache cargo registry&#10;      uses: actions/cache@v3&#10;      with:&#10;        path: |&#10;          ~/.cargo/registry&#10;          ~/.cargo/git&#10;          target&#10;        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}&#10;        restore-keys: |&#10;          ${{ runner.os }}-cargo-&#10;&#10;    - name: Install 7z (Ubuntu)&#10;      if: matrix.os == 'ubuntu-latest'&#10;      run: sudo apt-get update &amp;&amp; sudo apt-get install -y p7zip-full&#10;&#10;    - name: Install 7z (macOS)&#10;      if: matrix.os == 'macos-latest'&#10;      run: brew install p7zip&#10;&#10;    - name: Install 7z (Windows)&#10;      if: matrix.os == 'windows-latest'&#10;      run: choco install 7zip&#10;&#10;    - name: Check formatting&#10;      run: cargo fmt --all -- --check&#10;&#10;    - name: Run Clippy&#10;      run: cargo clippy --all-targets --all-features -- -D warnings&#10;&#10;    - name: Build&#10;      run: cargo build --verbose&#10;&#10;    - name: Run tests&#10;      run: cargo test --verbose&#10;&#10;  security_audit:&#10;    name: Security Audit&#10;    runs-on: ubuntu-latest&#10;    steps:&#10;    - uses: actions/checkout@v4&#10;    - uses: dtolnay/rust-toolchain@stable&#10;    - name: Install cargo-audit&#10;      run: cargo install cargo-audit&#10;    - name: Run cargo-audit&#10;      run: cargo audit&#10;&#10;  coverage:&#10;    name: Code Coverage&#10;    runs-on: ubuntu-latest&#10;    steps:&#10;    - uses: actions/checkout@v4&#10;    - uses: dtolnay/rust-toolchain@stable&#10;      with:&#10;        components: llvm-tools-preview&#10;&#10;    - name: Install 7z&#10;      run: sudo apt-get update &amp;&amp; sudo apt-get install -y p7zip-full&#10;&#10;    - name: Install cargo-llvm-cov&#10;      run: cargo install cargo-llvm-cov&#10;&#10;    - name: Generate code coverage&#10;      run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info&#10;&#10;    - name: Upload coverage to Codecov&#10;      uses: codecov/codecov-action@v3&#10;      with:&#10;        files: lcov.info&#10;        fail_ci_if_error: true&#10;&#10;  release:&#10;    name: Release Build&#10;    runs-on: ${{ matrix.os }}&#10;    if: github.event_name == 'push' &amp;&amp; github.ref == 'refs/heads/main'&#10;    strategy:&#10;      matrix:&#10;        include:&#10;          - os: ubuntu-latest&#10;            target: x86_64-unknown-linux-gnu&#10;            artifact_name: idea-backup&#10;            asset_name: idea-backup-linux-x86_64&#10;          - os: windows-latest&#10;            target: x86_64-pc-windows-msvc&#10;            artifact_name: idea-backup.exe&#10;            asset_name: idea-backup-windows-x86_64.exe&#10;          - os: macos-latest&#10;            target: x86_64-apple-darwin&#10;            artifact_name: idea-backup&#10;            asset_name: idea-backup-macos-x86_64&#10;          - os: macos-latest&#10;            target: aarch64-apple-darwin&#10;            artifact_name: idea-backup&#10;            asset_name: idea-backup-macos-aarch64&#10;&#10;    steps:&#10;    - uses: actions/checkout@v4&#10;&#10;    - name: Install Rust&#10;      uses: dtolnay/rust-toolchain@stable&#10;      with:&#10;        targets: ${{ matrix.target }}&#10;&#10;    - name: Install 7z (Ubuntu)&#10;      if: matrix.os == 'ubuntu-latest'&#10;      run: sudo apt-get update &amp;&amp; sudo apt-get install -y p7zip-full&#10;&#10;    - name: Install 7z (macOS)&#10;      if: matrix.os == 'macos-latest'&#10;      run: brew install p7zip&#10;&#10;    - name: Install 7z (Windows)&#10;      if: matrix.os == 'windows-latest'&#10;      run: choco install 7zip&#10;&#10;    - name: Build release&#10;      run: cargo build --release --target ${{ matrix.target }}&#10;&#10;    - name: Strip binary (Linux and macOS)&#10;      if: matrix.os == 'ubuntu-latest' || matrix.os == 'macos-latest'&#10;      run: strip target/${{ matrix.target }}/release/${{ matrix.artifact_name }}&#10;&#10;    - name: Upload artifacts&#10;      uses: actions/upload-artifact@v3&#10;      with:&#10;        name: ${{ matrix.asset_name }}&#10;        path: target/${{ matrix.target }}/release/${{ matrix.artifact_name }}&#10;&#10;  docs:&#10;    name: Documentation&#10;    runs-on: ubuntu-latest&#10;    steps:&#10;    - uses: actions/checkout@v4&#10;    - uses: dtolnay/rust-toolchain@stable&#10;    &#10;    - name: Build documentation&#10;      run: cargo doc --no-deps --document-private-items&#10;&#10;    - name: Deploy to GitHub Pages&#10;      if: github.ref == 'refs/heads/main'&#10;      uses: peaceiris/actions-gh-pages@v3&#10;      with:&#10;        github_token: ${{ secrets.GITHUB_TOKEN }}&#10;        publish_dir: target/doc" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Cargo.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Cargo.toml" />
              <option name="originalContent" value="[package]&#10;name = &quot;idea-backup&quot;&#10;version = &quot;0.1.0&quot;&#10;edition = &quot;2024&quot;&#10;&#10;[[bin]]&#10;name = &quot;idea-backup&quot;&#10;path = &quot;src/main.rs&quot;&#10;&#10;[[bin]]&#10;name = &quot;7z-extractor&quot;&#10;path = &quot;src/extractor.rs&quot;&#10;&#10;[dependencies]&#10;clap = { version = &quot;4.5.42&quot;, features = [&quot;derive&quot;] }&#10;dotenv = &quot;0.15&quot;&#10;ignore = &quot;0.4&quot;&#10;dirs = &quot;6.0.0&quot;&#10;serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }&#10;serde_json = &quot;1.0&quot;&#10;" />
              <option name="updatedContent" value="[package]&#10;name = &quot;idea-backup&quot;&#10;version = &quot;0.1.0&quot;&#10;edition = &quot;2024&quot;&#10;&#10;[[bin]]&#10;name = &quot;idea-backup&quot;&#10;path = &quot;src/main.rs&quot;&#10;&#10;[[bin]]&#10;name = &quot;7z-extractor&quot;&#10;path = &quot;src/extractor.rs&quot;&#10;&#10;[dependencies]&#10;clap = { version = &quot;4.5.42&quot;, features = [&quot;derive&quot;] }&#10;dotenv = &quot;0.15&quot;&#10;dirs = &quot;6.0.0&quot;&#10;serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }&#10;serde_json = &quot;1.0&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Idea Backup&#10;&#10;一个用于自动备份项目的 Rust 命令行工具，支持智能快照管理和增量备份。&#10;&#10;## 特性&#10;&#10;-  **智能快照管理** - 只备份有变化的项目，避免重复备份&#10;-  **自定义输入目录** - 支持指定任意项目目录，默认为 `~/IdeaProjects`&#10;-  **7z 加密压缩** - 使用密码保护的 7z 格式压缩备份文件&#10;-  **完整 .gitignore 支持** - 自动解析多层级 .gitignore 文件，支持 `**` 通配符&#10;-  **包含 Git 历史** - 可选择备份完整的 .git 目录和历史记录&#10;-  **路径扩展** - 支持 `~` 和 `.` 字符的路径解析&#10;-  **详细统计** - 显示备份过程和结果统计&#10;&#10;## 安装&#10;&#10;### 从源码构建&#10;&#10;```bash&#10;git clone https://github.com/your-username/idea-backup.git&#10;cd idea-backup&#10;cargo build --release&#10;```&#10;&#10;编译后的可执行文件位于 `target/release/idea-backup`&#10;&#10;### 系统要求&#10;&#10;- Rust 1.70+&#10;- 7z 工具（macOS 通过 Homebrew 自动安装）&#10;&#10;## 使用方法&#10;&#10;### 基本用法&#10;&#10;```bash&#10;# 使用默认设置备份 ~/IdeaProjects 目录&#10;./idea-backup -p your_password&#10;&#10;# 指定输入和输出目录&#10;./idea-backup -p your_password -i ~/MyProjects -o ~/Backups&#10;&#10;# 强制备份所有项目（忽略快照检查）&#10;./idea-backup -p your_password --force&#10;```&#10;&#10;### 命令行参数&#10;&#10;```&#10;USAGE:&#10;    idea-backup [OPTIONS]&#10;&#10;OPTIONS:&#10;    -p, --password &lt;PASSWORD&gt;    压缩文件的密码（优先于 .env 文件）&#10;    -i, --input &lt;INPUT&gt;          要扫描的项目目录 [default: ~/IdeaProjects]&#10;    -o, --output &lt;OUTPUT&gt;        备份文件的输出目录&#10;    -f, --force                  强制备份所有项目，忽略变更检测&#10;    -h, --help                   显示帮助信息&#10;```&#10;&#10;### 环境变量配置&#10;&#10;你可以创建 `.env` 文件来配置默认密码：&#10;&#10;```bash&#10;# .env 文件&#10;ZIP_PASSWORD=your_secure_password&#10;```&#10;&#10;## 工作原理&#10;&#10;### 快照管理&#10;&#10;工具会在输出目录创建 `.backup_snapshots.json` 文件来跟踪每个项目的状态：&#10;&#10;```json&#10;{&#10;  &quot;projects&quot;: {&#10;    &quot;my-project&quot;: {&#10;      &quot;path&quot;: &quot;/Users/username/IdeaProjects/my-project&quot;,&#10;      &quot;last_modified&quot;: 1672531200,&#10;      &quot;last_backup&quot;: 1672531200&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;### 智能备份逻辑&#10;&#10;1. **首次运行** - 备份所有发现的项目&#10;2. **后续运行** - 只备份有文件变更的项目&#10;3. **变更检测** - 遍历项目文件，比较最新修改时间&#10;4. **增量优化** - 快速检查避免不必要的完整遍历&#10;&#10;### .gitignore 支持&#10;&#10;- ✅ 支持多层级 .gitignore 文件&#10;- ✅ 支持标准 gitignore 语法（`*`, `**`, `!`, `/`）&#10;- ✅ 支持否定规则 (`!important.file`)&#10;- ✅ 支持目录专用规则 (`build/`)&#10;- ✅ 支持绝对路径规则 (`/root-only`)&#10;&#10;## 输出文件&#10;&#10;每个项目会生成一个加密的 7z 文件：&#10;&#10;```&#10;~/IdeaProjects/&#10;├── my-project/&#10;└── backups/&#10;    ├── my-project_backup.7z&#10;    ├── another-project_backup.7z&#10;    └── .backup_snapshots.json&#10;```&#10;&#10;## 解压工具&#10;&#10;项目包含一个配套的解压工具：&#10;&#10;```bash&#10;# 解压备份文件&#10;./7z-extractor path/to/backup.7z output_directory&#10;```&#10;&#10;## 开发&#10;&#10;### 运行测试&#10;&#10;```bash&#10;cargo test&#10;```&#10;&#10;### 代码检查&#10;&#10;```bash&#10;cargo clippy&#10;```&#10;&#10;### 格式化代码&#10;&#10;```bash&#10;cargo fmt&#10;```&#10;&#10;## 贡献&#10;&#10;1. Fork 这个仓库&#10;2. 创建你的特性分支 (`git checkout -b feature/amazing-feature`)&#10;3. 提交你的更改 (`git commit -m 'Add some amazing feature'`)&#10;4. 推送到分支 (`git push origin feature/amazing-feature`)&#10;5. 打开一个 Pull Request&#10;&#10;## 许可证&#10;&#10;MIT License - 查看 [LICENSE](LICENSE) 文件了解详情&#10;&#10;## 更新日志&#10;&#10;### v0.1.0&#10;- 初始版本&#10;- 智能快照管理&#10;- 完整 .gitignore 支持&#10;- 7z 加密压缩&#10;- 路径扩展支持&#10;&#10;## 技术栈&#10;&#10;- **Rust** - 系统编程语言&#10;- **clap** - 命令行参数解析&#10;- **serde** - 序列化/反序列化&#10;- **7z** - 压缩工具" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/file_walker.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/file_walker.rs" />
              <option name="originalContent" value="use std::fs;&#10;use std::path::{Path, PathBuf};&#10;use std::time::UNIX_EPOCH;&#10;&#10;/// 自定义文件遍历器&#10;pub struct FileWalker {&#10;    ignore_patterns: Vec&lt;GitIgnoreRule&gt;,&#10;    include_hidden: bool,&#10;    include_git: bool,&#10;}&#10;&#10;/// Git 忽略规则&#10;#[derive(Debug, Clone)]&#10;struct GitIgnoreRule {&#10;    pattern: String,&#10;    is_negation: bool,       // 是否是否定规则（!开头）&#10;    is_directory_only: bool, // 是否只匹配目录（/结尾）&#10;    is_absolute: bool,       // 是否是绝对路径（/开头）&#10;    source_dir: PathBuf,     // 规则来源目录&#10;}&#10;&#10;/// 遍历结果&#10;#[derive(Debug)]&#10;pub struct WalkEntry {&#10;    path: PathBuf,&#10;    file_type: FileType,&#10;}&#10;&#10;#[derive(Debug)]&#10;pub enum FileType {&#10;    File,&#10;    Directory,&#10;}&#10;&#10;impl FileWalker {&#10;    /// 创建新的文件遍历器&#10;    pub fn new&lt;P: AsRef&lt;Path&gt;&gt;(root: P) -&gt; Self {&#10;        let mut walker = Self {&#10;            ignore_patterns: Vec::new(),&#10;            include_hidden: true,&#10;            include_git: true,&#10;        };&#10;&#10;        // 收集所有.gitignore文件的规则&#10;        walker.collect_gitignore_rules(root.as_ref());&#10;&#10;        walker&#10;    }&#10;&#10;    /// 设置是否包含隐藏文件&#10;    pub fn include_hidden(mut self, include: bool) -&gt; Self {&#10;        self.include_hidden = include;&#10;        self&#10;    }&#10;&#10;    /// 设置是否包含 .git 目录&#10;    pub fn include_git(mut self, include: bool) -&gt; Self {&#10;        self.include_git = include;&#10;        self&#10;    }&#10;&#10;    /// 递归收集所有.gitignore文件的规则&#10;    fn collect_gitignore_rules(&amp;mut self, dir: &amp;Path) {&#10;        let gitignore_path = dir.join(&quot;.gitignore&quot;);&#10;        if gitignore_path.exists() {&#10;            if let Ok(content) = fs::read_to_string(&amp;gitignore_path) {&#10;                self.load_gitignore_patterns(content, dir.to_path_buf());&#10;            }&#10;        }&#10;&#10;        // 递归处理子目录&#10;        if let Ok(entries) = fs::read_dir(dir) {&#10;            for entry in entries.flatten() {&#10;                let path = entry.path();&#10;                if path.is_dir() {&#10;                    let filename = path&#10;                        .file_name()&#10;                        .and_then(|name| name.to_str())&#10;                        .unwrap_or(&quot;&quot;);&#10;&#10;                    // 跳过.git目录和其他隐藏目录以避免无限递归&#10;                    if !filename.starts_with('.') {&#10;                        self.collect_gitignore_rules(&amp;path);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /// 从 .gitignore 内容加载忽略模式&#10;    fn load_gitignore_patterns(&amp;mut self, content: String, source_dir: PathBuf) {&#10;        for line in content.lines() {&#10;            let line = line.trim();&#10;            // 跳过空行和注释&#10;            if line.is_empty() || line.starts_with('#') {&#10;                continue;&#10;            }&#10;&#10;            let mut pattern = line.to_string();&#10;            let mut is_negation = false;&#10;            let mut is_directory_only = false;&#10;            let mut is_absolute = false;&#10;&#10;            // 处理否定规则&#10;            if pattern.starts_with('!') {&#10;                is_negation = true;&#10;                pattern = pattern[1..].to_string();&#10;            }&#10;&#10;            // 处理目录规则&#10;            if pattern.ends_with('/') {&#10;                is_directory_only = true;&#10;                pattern = pattern[..pattern.len() - 1].to_string();&#10;            }&#10;&#10;            // 处理绝对路径&#10;            if pattern.starts_with('/') {&#10;                is_absolute = true;&#10;                pattern = pattern[1..].to_string();&#10;            }&#10;&#10;            self.ignore_patterns.push(GitIgnoreRule {&#10;                pattern,&#10;                is_negation,&#10;                is_directory_only,&#10;                is_absolute,&#10;                source_dir: source_dir.clone(),&#10;            });&#10;        }&#10;    }&#10;&#10;    /// 检查文件路径是否应该被忽略&#10;    fn should_ignore(&amp;self, path: &amp;Path, root_path: &amp;Path) -&gt; bool {&#10;        let filename = path&#10;            .file_name()&#10;            .and_then(|name| name.to_str())&#10;            .unwrap_or(&quot;&quot;);&#10;&#10;        // 检查隐藏文件&#10;        if !self.include_hidden &amp;&amp; filename.starts_with('.') {&#10;            // 但如果设置了包含 .git，则不忽略 .git 目录&#10;            if !self.include_git || filename != &quot;.git&quot; {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // 如果不包含 .git 目录，则忽略它&#10;        if !self.include_git &amp;&amp; filename == &quot;.git&quot; {&#10;            return true;&#10;        }&#10;&#10;        // 获取相对于根目录的路径&#10;        let relative_path = match path.strip_prefix(root_path) {&#10;            Ok(rel) =&gt; rel,&#10;            Err(_) =&gt; return false,&#10;        };&#10;&#10;        let relative_str = relative_path.to_string_lossy();&#10;        let is_directory = path.is_dir();&#10;&#10;        let mut should_ignore = false;&#10;&#10;        // 检查所有gitignore规则&#10;        for rule in &amp;self.ignore_patterns {&#10;            if self.matches_rule(rule, &amp;relative_str, filename, is_directory, path, root_path) {&#10;                if rule.is_negation {&#10;                    return false; // 否定规则，不忽略&#10;                } else {&#10;                    should_ignore = true; // 正常规则，忽略&#10;                }&#10;            }&#10;        }&#10;&#10;        should_ignore&#10;    }&#10;&#10;    /// 检查路径是否匹配特定规则&#10;    fn matches_rule(&#10;        &amp;self,&#10;        rule: &amp;GitIgnoreRule,&#10;        relative_path: &amp;str,&#10;        filename: &amp;str,&#10;        is_directory: bool,&#10;        full_path: &amp;Path,&#10;        root_path: &amp;Path,&#10;    ) -&gt; bool {&#10;        // 如果规则只匹配目录，但当前是文件，则不匹配&#10;        if rule.is_directory_only &amp;&amp; !is_directory {&#10;            return false;&#10;        }&#10;&#10;        // 计算规则应用的相对路径&#10;        let rule_relative_path = if rule.source_dir == root_path {&#10;            relative_path&#10;        } else {&#10;            // 规则来自子目录，需要计算相对于该子目录的路径&#10;            &amp;*match full_path.strip_prefix(&amp;rule.source_dir) {&#10;                Ok(rel) =&gt; rel.to_string_lossy(),&#10;                Err(_) =&gt; {&#10;                    // 如果路径不在规则源目录下，则不匹配&#10;                    return false;&#10;                }&#10;            }&#10;        };&#10;&#10;        let rule_relative_str = rule_relative_path.as_ref();&#10;&#10;        if rule.is_absolute {&#10;            // 绝对路径匹配&#10;            self.pattern_matches(&amp;rule.pattern, rule_relative_str)&#10;        } else {&#10;            // 相对路径匹配，可以匹配任何层级&#10;            self.pattern_matches(&amp;rule.pattern, filename)&#10;                || self.pattern_matches(&amp;rule.pattern, rule_relative_str)&#10;                || rule_relative_str&#10;                    .split('/')&#10;                    .any(|part| self.pattern_matches(&amp;rule.pattern, part))&#10;        }&#10;    }&#10;&#10;    /// 模式匹配实现，支持 * 和 ** 通配符&#10;    fn pattern_matches(&amp;self, pattern: &amp;str, text: &amp;str) -&gt; bool {&#10;        if pattern == text {&#10;            return true;&#10;        }&#10;&#10;        // 处理 ** 通配符&#10;        if pattern.contains(&quot;**&quot;) {&#10;            return self.globstar_match(pattern, text);&#10;        }&#10;&#10;        // 处理普通 * 通配符&#10;        if pattern.contains('*') {&#10;            return self.wildcard_match(pattern, text);&#10;        }&#10;&#10;        // 检查是否是路径的一部分&#10;        text.split('/').any(|part| part == pattern)&#10;    }&#10;&#10;    /// 处理 ** 通配符匹配&#10;    fn globstar_match(&amp;self, pattern: &amp;str, text: &amp;str) -&gt; bool {&#10;        let parts: Vec&lt;&amp;str&gt; = pattern.split(&quot;**&quot;).collect();&#10;&#10;        if parts.len() == 1 {&#10;            return self.wildcard_match(pattern, text);&#10;        }&#10;&#10;        let prefix = parts[0];&#10;        let suffix = parts[parts.len() - 1];&#10;&#10;        // 简化处理：前缀匹配和后缀匹配&#10;        if prefix.is_empty() &amp;&amp; suffix.is_empty() {&#10;            return true; // ** 匹配任何内容&#10;        }&#10;&#10;        if prefix.is_empty() {&#10;            return text.ends_with(suffix.trim_start_matches('/'));&#10;        }&#10;&#10;        if suffix.is_empty() {&#10;            return text.starts_with(prefix.trim_end_matches('/'));&#10;        }&#10;&#10;        text.starts_with(prefix.trim_end_matches('/'))&#10;            &amp;&amp; text.ends_with(suffix.trim_start_matches('/'))&#10;    }&#10;&#10;    /// 简单的通配符匹配实现&#10;    fn wildcard_match(&amp;self, pattern: &amp;str, text: &amp;str) -&gt; bool {&#10;        let pattern_parts: Vec&lt;&amp;str&gt; = pattern.split('*').collect();&#10;&#10;        if pattern_parts.len() == 1 {&#10;            return text == pattern;&#10;        }&#10;&#10;        let mut text_pos = 0;&#10;&#10;        for (i, part) in pattern_parts.iter().enumerate() {&#10;            if part.is_empty() {&#10;                continue;&#10;            }&#10;&#10;            if i == 0 {&#10;                // 第一部分必须在开头匹配&#10;                if !text[text_pos..].starts_with(part) {&#10;                    return false;&#10;                }&#10;                text_pos += part.len();&#10;            } else if i == pattern_parts.len() - 1 {&#10;                // 最后一部分必须在结尾匹配&#10;                return text[text_pos..].ends_with(part);&#10;            } else {&#10;                // 中间部分需要找到匹配位置&#10;                if let Some(pos) = text[text_pos..].find(part) {&#10;                    text_pos += pos + part.len();&#10;                } else {&#10;                    return false;&#10;                }&#10;            }&#10;        }&#10;&#10;        true&#10;    }&#10;&#10;    /// 遍历目录并返回所有文件&#10;    pub fn walk&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, root: P) -&gt; Result&lt;Vec&lt;WalkEntry&gt;, std::io::Error&gt; {&#10;        let mut results = Vec::new();&#10;        let root_path = root.as_ref();&#10;&#10;        self.walk_recursive(root_path, root_path, &amp;mut results)?;&#10;&#10;        Ok(results)&#10;    }&#10;&#10;    /// 递归遍历目录&#10;    fn walk_recursive(&#10;        &amp;self,&#10;        current_path: &amp;Path,&#10;        root_path: &amp;Path,&#10;        results: &amp;mut Vec&lt;WalkEntry&gt;,&#10;    ) -&gt; Result&lt;(), std::io::Error&gt; {&#10;        let entries = fs::read_dir(current_path)?;&#10;&#10;        for entry in entries {&#10;            let entry = entry?;&#10;            let path = entry.path();&#10;            let metadata = entry.metadata()?;&#10;&#10;            // 检查是否应该忽略&#10;            if self.should_ignore(&amp;path, root_path) {&#10;                continue;&#10;            }&#10;&#10;            if metadata.is_file() {&#10;                results.push(WalkEntry {&#10;                    path: path.clone(),&#10;                    file_type: FileType::File,&#10;                });&#10;            } else if metadata.is_dir() {&#10;                results.push(WalkEntry {&#10;                    path: path.clone(),&#10;                    file_type: FileType::Directory,&#10;                });&#10;&#10;                // 递归遍历子目录&#10;                self.walk_recursive(&amp;path, root_path, results)?;&#10;            }&#10;        }&#10;&#10;        Ok(())&#10;    }&#10;&#10;    /// 获取目录中最新的修改时间&#10;    pub fn get_latest_modification_time&lt;P: AsRef&lt;Path&gt;&gt;(&#10;        &amp;self,&#10;        root: P,&#10;    ) -&gt; Result&lt;u64, Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let entries = self.walk(root)?;&#10;        let mut latest_time = 0u64;&#10;&#10;        for entry in entries {&#10;            if matches!(entry.file_type, FileType::File) {&#10;                if let Ok(metadata) = fs::metadata(&amp;entry.path) {&#10;                    if let Ok(modified) = metadata.modified() {&#10;                        if let Ok(duration) = modified.duration_since(UNIX_EPOCH) {&#10;                            let timestamp = duration.as_secs();&#10;                            if timestamp &gt; latest_time {&#10;                                latest_time = timestamp;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Ok(latest_time)&#10;    }&#10;&#10;    /// 检查目录是否有文件在指定时间之后被修改&#10;    pub fn has_modifications_after&lt;P: AsRef&lt;Path&gt;&gt;(&#10;        &amp;self,&#10;        root: P,&#10;        after_timestamp: u64,&#10;    ) -&gt; Result&lt;bool, Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let entries = self.walk(root)?;&#10;&#10;        for entry in entries {&#10;            if matches!(entry.file_type, FileType::File) {&#10;                if let Ok(metadata) = fs::metadata(&amp;entry.path) {&#10;                    if let Ok(modified) = metadata.modified() {&#10;                        if let Ok(duration) = modified.duration_since(UNIX_EPOCH) {&#10;                            let timestamp = duration.as_secs();&#10;                            if timestamp &gt; after_timestamp {&#10;                                return Ok(true); // 找到了更新的文件，立即返回&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Ok(false) // 没有找到更新的文件&#10;    }&#10;&#10;    /// 复制文件并保持目录结构&#10;    pub fn copy_files_to&lt;P: AsRef&lt;Path&gt;, Q: AsRef&lt;Path&gt;&gt;(&#10;        &amp;self,&#10;        source_root: P,&#10;        dest_root: Q,&#10;    ) -&gt; Result&lt;usize, Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let entries = self.walk(&amp;source_root)?;&#10;        let mut file_count = 0;&#10;        let source_root = source_root.as_ref();&#10;        let dest_root = dest_root.as_ref();&#10;&#10;        for entry in entries {&#10;            if matches!(entry.file_type, FileType::File) {&#10;                // 计算相对路径&#10;                let relative_path = entry.path.strip_prefix(source_root)?;&#10;                let dest_path = dest_root.join(relative_path);&#10;&#10;                // 确保目标目录存在&#10;                if let Some(parent) = dest_path.parent() {&#10;                    fs::create_dir_all(parent)?;&#10;                }&#10;&#10;                // 复制文件&#10;                fs::copy(&amp;entry.path, &amp;dest_path)?;&#10;                file_count += 1;&#10;            }&#10;        }&#10;&#10;        Ok(file_count)&#10;    }&#10;}&#10;&#10;#[cfg(test)]&#10;mod test {&#10;    use std::path::{Path, PathBuf};&#10;&#10;    fn setup_test_dir() {&#10;        // 创建测试目录&#10;        let temp_dir = PathBuf::from(&quot;test_temp&quot;);&#10;        if temp_dir.exists() {&#10;            std::fs::remove_dir_all(&amp;temp_dir).expect(&quot;无法清理测试目录&quot;);&#10;        }&#10;        std::fs::create_dir_all(&amp;temp_dir).expect(&quot;无法创建测试目录&quot;);&#10;    }&#10;&#10;    fn test_write_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P, content: &amp;str) {&#10;        let file_path = path.as_ref();&#10;        if let Some(parent) = file_path.parent() {&#10;            std::fs::create_dir_all(parent).expect(&quot;无法创建父目录&quot;);&#10;        }&#10;        std::fs::write(file_path, content).expect(&quot;无法写入测试文件&quot;);&#10;    }&#10;&#10;    #[test]&#10;    fn test_gradle_and_build() {&#10;        /*&#10;                .gradle&#10;                build/&#10;        */&#10;        use super::*;&#10;&#10;        setup_test_dir();&#10;        let temp_dir = PathBuf::from(&quot;test_temp&quot;);&#10;        let mut walker = FileWalker::new(&amp;temp_dir)&#10;            .include_hidden(true)&#10;            .include_git(false);&#10;        // 写入.gitignore文件&#10;        test_write_file(temp_dir.join(&quot;.gitignore&quot;), &quot;.gradle\nbuild/\n&quot;);&#10;        walker.collect_gitignore_rules(&amp;temp_dir);&#10;        // 创建测试文件&#10;        test_write_file(temp_dir.join(&quot;test.txt&quot;), &quot;test content&quot;);&#10;        test_write_file(temp_dir.join(&quot;.gradle/test.txt&quot;), &quot;gradle content&quot;);&#10;        test_write_file(temp_dir.join(&quot;build/test.txt&quot;), &quot;build content&quot;);&#10;        test_write_file(temp_dir.join(&quot;subdir/test.txt&quot;), &quot;subdir content&quot;);&#10;        // 测试遍历&#10;        let entries = walker.walk(&amp;temp_dir).expect(&quot;无法遍历测试目录&quot;);&#10;        // 检查结果&#10;        assert!(entries.iter().any(|e| e.path.ends_with(&quot;test.txt&quot;)));&#10;        assert!(entries.iter().any(|e| e.path.ends_with(&quot;.gitignore&quot;)));&#10;        assert!(entries.iter().any(|e| e.path.ends_with(&quot;subdir&quot;)));&#10;        assert!(entries.iter().any(|e| e.path.ends_with(&quot;subdir/test.txt&quot;)));&#10;        assert_eq!(entries.len(), 4); // 应该只包含 test.txt, subdir/test.txt&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="use std::fs;&#10;use std::path::{Path, PathBuf};&#10;use std::time::UNIX_EPOCH;&#10;&#10;/// 自定义文件遍历器&#10;pub struct FileWalker {&#10;    ignore_patterns: Vec&lt;GitIgnoreRule&gt;,&#10;    include_hidden: bool,&#10;    include_git: bool,&#10;}&#10;&#10;/// Git 忽略规则&#10;#[derive(Debug, Clone)]&#10;struct GitIgnoreRule {&#10;    pattern: String,&#10;    is_negation: bool,       // 是否是否定规则（!开头）&#10;    is_directory_only: bool, // 是否只匹配目录（/结尾）&#10;    is_absolute: bool,       // 是否是绝对路径（/开头）&#10;    source_dir: PathBuf,     // 规则来源目录&#10;}&#10;&#10;/// 遍历结果&#10;#[derive(Debug)]&#10;pub struct WalkEntry {&#10;    path: PathBuf,&#10;    file_type: FileType,&#10;}&#10;&#10;#[derive(Debug)]&#10;pub enum FileType {&#10;    File,&#10;    Directory,&#10;}&#10;&#10;impl FileWalker {&#10;    /// 创建新的文件遍历器&#10;    pub fn new&lt;P: AsRef&lt;Path&gt;&gt;(root: P) -&gt; Self {&#10;        let mut walker = Self {&#10;            ignore_patterns: Vec::new(),&#10;            include_hidden: true,&#10;            include_git: true,&#10;        };&#10;&#10;        // 收集所有.gitignore文件的规则&#10;        walker.collect_gitignore_rules(root.as_ref());&#10;&#10;        walker&#10;    }&#10;&#10;    /// 设置是否包含隐藏文件&#10;    pub fn include_hidden(mut self, include: bool) -&gt; Self {&#10;        self.include_hidden = include;&#10;        self&#10;    }&#10;&#10;    /// 设置是否包含 .git 目录&#10;    pub fn include_git(mut self, include: bool) -&gt; Self {&#10;        self.include_git = include;&#10;        self&#10;    }&#10;&#10;    /// 递归收集所有.gitignore文件的规则&#10;    fn collect_gitignore_rules(&amp;mut self, dir: &amp;Path) {&#10;        let gitignore_path = dir.join(&quot;.gitignore&quot;);&#10;        if gitignore_path.exists() {&#10;            if let Ok(content) = fs::read_to_string(&amp;gitignore_path) {&#10;                self.load_gitignore_patterns(content, dir.to_path_buf());&#10;            }&#10;        }&#10;&#10;        // 递归处理子目录&#10;        if let Ok(entries) = fs::read_dir(dir) {&#10;            for entry in entries.flatten() {&#10;                let path = entry.path();&#10;                if path.is_dir() {&#10;                    let filename = path&#10;                        .file_name()&#10;                        .and_then(|name| name.to_str())&#10;                        .unwrap_or(&quot;&quot;);&#10;&#10;                    // 跳过.git目录和其他隐藏目录以避免无限递归&#10;                    if !filename.starts_with('.') {&#10;                        self.collect_gitignore_rules(&amp;path);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /// 从 .gitignore 内容加载忽略模式&#10;    fn load_gitignore_patterns(&amp;mut self, content: String, source_dir: PathBuf) {&#10;        for line in content.lines() {&#10;            let line = line.trim();&#10;            // 跳过空行和注释&#10;            if line.is_empty() || line.starts_with('#') {&#10;                continue;&#10;            }&#10;&#10;            let mut pattern = line.to_string();&#10;            let mut is_negation = false;&#10;            let mut is_directory_only = false;&#10;            let mut is_absolute = false;&#10;&#10;            // 处理否定规则&#10;            if pattern.starts_with('!') {&#10;                is_negation = true;&#10;                pattern = pattern[1..].to_string();&#10;            }&#10;&#10;            // 处理目录规则&#10;            if pattern.ends_with('/') {&#10;                is_directory_only = true;&#10;                pattern = pattern[..pattern.len() - 1].to_string();&#10;            }&#10;&#10;            // 处理绝对路径&#10;            if pattern.starts_with('/') {&#10;                is_absolute = true;&#10;                pattern = pattern[1..].to_string();&#10;            }&#10;&#10;            self.ignore_patterns.push(GitIgnoreRule {&#10;                pattern,&#10;                is_negation,&#10;                is_directory_only,&#10;                is_absolute,&#10;                source_dir: source_dir.clone(),&#10;            });&#10;        }&#10;    }&#10;&#10;    /// 检查文件路径是否应该被忽略&#10;    fn should_ignore(&amp;self, path: &amp;Path, root_path: &amp;Path) -&gt; bool {&#10;        let filename = path&#10;            .file_name()&#10;            .and_then(|name| name.to_str())&#10;            .unwrap_or(&quot;&quot;);&#10;&#10;        // 检查隐藏文件&#10;        if !self.include_hidden &amp;&amp; filename.starts_with('.') {&#10;            // 但如果设置了包含 .git，则不忽略 .git 目录&#10;            if !self.include_git || filename != &quot;.git&quot; {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // 如果不包含 .git 目录，则忽略它&#10;        if !self.include_git &amp;&amp; filename == &quot;.git&quot; {&#10;            return true;&#10;        }&#10;&#10;        // 获取相对于根目录的路径&#10;        let relative_path = match path.strip_prefix(root_path) {&#10;            Ok(rel) =&gt; rel,&#10;            Err(_) =&gt; return false,&#10;        };&#10;&#10;        let relative_str = relative_path.to_string_lossy();&#10;        let is_directory = path.is_dir();&#10;&#10;        let mut should_ignore = false;&#10;&#10;        // 检查所有gitignore规则&#10;        for rule in &amp;self.ignore_patterns {&#10;            if self.matches_rule(rule, &amp;relative_str, filename, is_directory, path, root_path) {&#10;                if rule.is_negation {&#10;                    return false; // 否定规则，不忽略&#10;                } else {&#10;                    should_ignore = true; // 正常规则，忽略&#10;                }&#10;            }&#10;        }&#10;&#10;        should_ignore&#10;    }&#10;&#10;    /// 检查路径是否匹配特定规则&#10;    fn matches_rule(&#10;        &amp;self,&#10;        rule: &amp;GitIgnoreRule,&#10;        relative_path: &amp;str,&#10;        filename: &amp;str,&#10;        is_directory: bool,&#10;        full_path: &amp;Path,&#10;        root_path: &amp;Path,&#10;    ) -&gt; bool {&#10;        // 如果规则只匹配目录，但当前是文件，则不匹配&#10;        if rule.is_directory_only &amp;&amp; !is_directory {&#10;            return false;&#10;        }&#10;&#10;        // 计算规则应用的相对路径&#10;        let rule_relative_path = if rule.source_dir == root_path {&#10;            relative_path&#10;        } else {&#10;            // 规则来自子目录，需要计算相对于该子目录的路径&#10;            &amp;*match full_path.strip_prefix(&amp;rule.source_dir) {&#10;                Ok(rel) =&gt; rel.to_string_lossy(),&#10;                Err(_) =&gt; {&#10;                    // 如果路径不在规则源目录下，则不匹配&#10;                    return false;&#10;                }&#10;            }&#10;        };&#10;&#10;        let rule_relative_str = rule_relative_path.as_ref();&#10;&#10;        if rule.is_absolute {&#10;            // 绝对路径匹配&#10;            self.pattern_matches(&amp;rule.pattern, rule_relative_str)&#10;        } else {&#10;            // 相对路径匹配，可以匹配任何层级&#10;            self.pattern_matches(&amp;rule.pattern, filename)&#10;                || self.pattern_matches(&amp;rule.pattern, rule_relative_str)&#10;                || rule_relative_str&#10;                    .split('/')&#10;                    .any(|part| self.pattern_matches(&amp;rule.pattern, part))&#10;        }&#10;    }&#10;&#10;    /// 模式匹配实现，支持 * 和 ** 通配符&#10;    fn pattern_matches(&amp;self, pattern: &amp;str, text: &amp;str) -&gt; bool {&#10;        if pattern == text {&#10;            return true;&#10;        }&#10;&#10;        // 处理 ** 通配符&#10;        if pattern.contains(&quot;**&quot;) {&#10;            return self.globstar_match(pattern, text);&#10;        }&#10;&#10;        // 处理普通 * 通配符&#10;        if pattern.contains('*') {&#10;            return self.wildcard_match(pattern, text);&#10;        }&#10;&#10;        // 检查是否是路径的一部分&#10;        text.split('/').any(|part| part == pattern)&#10;    }&#10;&#10;    /// 处理 ** 通配符匹配&#10;    fn globstar_match(&amp;self, pattern: &amp;str, text: &amp;str) -&gt; bool {&#10;        let parts: Vec&lt;&amp;str&gt; = pattern.split(&quot;**&quot;).collect();&#10;&#10;        if parts.len() == 1 {&#10;            return self.wildcard_match(pattern, text);&#10;        }&#10;&#10;        let prefix = parts[0];&#10;        let suffix = parts[parts.len() - 1];&#10;&#10;        // 简化处理：前缀匹配和后缀匹配&#10;        if prefix.is_empty() &amp;&amp; suffix.is_empty() {&#10;            return true; // ** 匹配任何内容&#10;        }&#10;&#10;        if prefix.is_empty() {&#10;            return text.ends_with(suffix.trim_start_matches('/'));&#10;        }&#10;&#10;        if suffix.is_empty() {&#10;            return text.starts_with(prefix.trim_end_matches('/'));&#10;        }&#10;&#10;        text.starts_with(prefix.trim_end_matches('/'))&#10;            &amp;&amp; text.ends_with(suffix.trim_start_matches('/'))&#10;    }&#10;&#10;    /// 简单的通配符匹配实现&#10;    fn wildcard_match(&amp;self, pattern: &amp;str, text: &amp;str) -&gt; bool {&#10;        let pattern_parts: Vec&lt;&amp;str&gt; = pattern.split('*').collect();&#10;&#10;        if pattern_parts.len() == 1 {&#10;            return text == pattern;&#10;        }&#10;&#10;        let mut text_pos = 0;&#10;&#10;        for (i, part) in pattern_parts.iter().enumerate() {&#10;            if part.is_empty() {&#10;                continue;&#10;            }&#10;&#10;            if i == 0 {&#10;                // 第一部分必须在开头匹配&#10;                if !text[text_pos..].starts_with(part) {&#10;                    return false;&#10;                }&#10;                text_pos += part.len();&#10;            } else if i == pattern_parts.len() - 1 {&#10;                // 最后一部分必须在结尾匹配&#10;                return text[text_pos..].ends_with(part);&#10;            } else {&#10;                // 中间部分需要找到匹配位置&#10;                if let Some(pos) = text[text_pos..].find(part) {&#10;                    text_pos += pos + part.len();&#10;                } else {&#10;                    return false;&#10;                }&#10;            }&#10;        }&#10;&#10;        true&#10;    }&#10;&#10;    /// 遍历目录并返回所有文件&#10;    pub fn walk&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, root: P) -&gt; Result&lt;Vec&lt;WalkEntry&gt;, std::io::Error&gt; {&#10;        let mut results = Vec::new();&#10;        let root_path = root.as_ref();&#10;&#10;        self.walk_recursive(root_path, root_path, &amp;mut results)?;&#10;&#10;        Ok(results)&#10;    }&#10;&#10;    /// 递归遍历目录&#10;    fn walk_recursive(&#10;        &amp;self,&#10;        current_path: &amp;Path,&#10;        root_path: &amp;Path,&#10;        results: &amp;mut Vec&lt;WalkEntry&gt;,&#10;    ) -&gt; Result&lt;(), std::io::Error&gt; {&#10;        let entries = fs::read_dir(current_path)?;&#10;&#10;        for entry in entries {&#10;            let entry = entry?;&#10;            let path = entry.path();&#10;            let metadata = entry.metadata()?;&#10;&#10;            // 检查是否应该忽略&#10;            if self.should_ignore(&amp;path, root_path) {&#10;                continue;&#10;            }&#10;&#10;            if metadata.is_file() {&#10;                results.push(WalkEntry {&#10;                    path: path.clone(),&#10;                    file_type: FileType::File,&#10;                });&#10;            } else if metadata.is_dir() {&#10;                results.push(WalkEntry {&#10;                    path: path.clone(),&#10;                    file_type: FileType::Directory,&#10;                });&#10;&#10;                // 递归遍历子目录&#10;                self.walk_recursive(&amp;path, root_path, results)?;&#10;            }&#10;        }&#10;&#10;        Ok(())&#10;    }&#10;&#10;    /// 获取目录中最新的修改时间&#10;    pub fn get_latest_modification_time&lt;P: AsRef&lt;Path&gt;&gt;(&#10;        &amp;self,&#10;        root: P,&#10;    ) -&gt; Result&lt;u64, Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let entries = self.walk(root)?;&#10;        let mut latest_time = 0u64;&#10;&#10;        for entry in entries {&#10;            if matches!(entry.file_type, FileType::File) {&#10;                if let Ok(metadata) = fs::metadata(&amp;entry.path) {&#10;                    if let Ok(modified) = metadata.modified() {&#10;                        if let Ok(duration) = modified.duration_since(UNIX_EPOCH) {&#10;                            let timestamp = duration.as_secs();&#10;                            if timestamp &gt; latest_time {&#10;                                latest_time = timestamp;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Ok(latest_time)&#10;    }&#10;&#10;    /// 检查目录是否有文件在指定时间之后被修改&#10;    pub fn has_modifications_after&lt;P: AsRef&lt;Path&gt;&gt;(&#10;        &amp;self,&#10;        root: P,&#10;        after_timestamp: u64,&#10;    ) -&gt; Result&lt;bool, Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let entries = self.walk(root)?;&#10;&#10;        for entry in entries {&#10;            if matches!(entry.file_type, FileType::File) {&#10;                if let Ok(metadata) = fs::metadata(&amp;entry.path) {&#10;                    if let Ok(modified) = metadata.modified() {&#10;                        if let Ok(duration) = modified.duration_since(UNIX_EPOCH) {&#10;                            let timestamp = duration.as_secs();&#10;                            if timestamp &gt; after_timestamp {&#10;                                return Ok(true); // 找到了更新的文件，立即返回&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Ok(false) // 没有找到更新的文件&#10;    }&#10;&#10;    /// 复制文件并保持目录结构&#10;    pub fn copy_files_to&lt;P: AsRef&lt;Path&gt;, Q: AsRef&lt;Path&gt;&gt;(&#10;        &amp;self,&#10;        source_root: P,&#10;        dest_root: Q,&#10;    ) -&gt; Result&lt;usize, Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let entries = self.walk(&amp;source_root)?;&#10;        let mut file_count = 0;&#10;        let source_root = source_root.as_ref();&#10;        let dest_root = dest_root.as_ref();&#10;&#10;        for entry in entries {&#10;            if matches!(entry.file_type, FileType::File) {&#10;                // 计算相对路径&#10;                let relative_path = entry.path.strip_prefix(source_root)?;&#10;                let dest_path = dest_root.join(relative_path);&#10;&#10;                // 确保目标目录存在&#10;                if let Some(parent) = dest_path.parent() {&#10;                    fs::create_dir_all(parent)?;&#10;                }&#10;&#10;                // 复制文件&#10;                fs::copy(&amp;entry.path, &amp;dest_path)?;&#10;                file_count += 1;&#10;            }&#10;        }&#10;&#10;        Ok(file_count)&#10;    }&#10;}&#10;&#10;#[cfg(test)]&#10;mod tests {&#10;    use super::*;&#10;    use std::fs;&#10;    use std::path::PathBuf;&#10;&#10;    fn setup_test_dir() -&gt; PathBuf {&#10;        let temp_dir = std::env::temp_dir().join(&quot;idea_backup_test&quot;);&#10;        &#10;        // 清理可能存在的测试目录&#10;        if temp_dir.exists() {&#10;            fs::remove_dir_all(&amp;temp_dir).expect(&quot;无法清理测试目录&quot;);&#10;        }&#10;        &#10;        // 创建测试目录结构&#10;        fs::create_dir_all(&amp;temp_dir).expect(&quot;无法创建测试目录&quot;);&#10;        fs::create_dir_all(temp_dir.join(&quot;src&quot;)).expect(&quot;无法创建src目录&quot;);&#10;        fs::create_dir_all(temp_dir.join(&quot;target&quot;)).expect(&quot;无法创建target目录&quot;);&#10;        fs::create_dir_all(temp_dir.join(&quot;.git&quot;)).expect(&quot;无法创建.git目录&quot;);&#10;        &#10;        // 创建测试文件&#10;        fs::write(temp_dir.join(&quot;Cargo.toml&quot;), &quot;[package]\nname = \&quot;test\&quot;\n&quot;).expect(&quot;无法创建Cargo.toml&quot;);&#10;        fs::write(temp_dir.join(&quot;src/main.rs&quot;), &quot;fn main() {}\n&quot;).expect(&quot;无法创建main.rs&quot;);&#10;        fs::write(temp_dir.join(&quot;target/test.bin&quot;), &quot;binary\n&quot;).expect(&quot;无法创建binary文件&quot;);&#10;        fs::write(temp_dir.join(&quot;.git/config&quot;), &quot;[core]\n&quot;).expect(&quot;无法创建git配置&quot;);&#10;        fs::write(temp_dir.join(&quot;README.md&quot;), &quot;# Test Project\n&quot;).expect(&quot;无法创建README&quot;);&#10;        &#10;        // 创建 .gitignore 文件&#10;        fs::write(temp_dir.join(&quot;.gitignore&quot;), &quot;target/\n*.log\n&quot;).expect(&quot;无法创建.gitignore&quot;);&#10;        &#10;        temp_dir&#10;    }&#10;&#10;    #[test]&#10;    fn test_file_walker_basic() {&#10;        let test_dir = setup_test_dir();&#10;        let walker = FileWalker::new(&amp;test_dir);&#10;        &#10;        let entries = walker.walk(&amp;test_dir).expect(&quot;遍历失败&quot;);&#10;        &#10;        // 应该包含一些文件，但排除 target/ 目录下的内容&#10;        assert!(!entries.is_empty());&#10;        &#10;        // 验证包含了预期的文件&#10;        let paths: Vec&lt;String&gt; = entries.iter()&#10;            .map(|e| e.path().strip_prefix(&amp;test_dir).unwrap().to_string_lossy().to_string())&#10;            .collect();&#10;        &#10;        assert!(paths.iter().any(|p| p == &quot;Cargo.toml&quot;));&#10;        assert!(paths.iter().any(|p| p == &quot;src/main.rs&quot;));&#10;        assert!(paths.iter().any(|p| p == &quot;README.md&quot;));&#10;        &#10;        // 清理&#10;        fs::remove_dir_all(&amp;test_dir).ok();&#10;    }&#10;&#10;    #[test]&#10;    fn test_gitignore_filtering() {&#10;        let test_dir = setup_test_dir();&#10;        let walker = FileWalker::new(&amp;test_dir);&#10;        &#10;        let entries = walker.walk(&amp;test_dir).expect(&quot;遍历失败&quot;);&#10;        let paths: Vec&lt;String&gt; = entries.iter()&#10;            .map(|e| e.path().strip_prefix(&amp;test_dir).unwrap().to_string_lossy().to_string())&#10;            .collect();&#10;        &#10;        // target/ 目录下的文件应该被忽略&#10;        assert!(!paths.iter().any(|p| p.starts_with(&quot;target/&quot;)));&#10;        &#10;        // 清理&#10;        fs::remove_dir_all(&amp;test_dir).ok();&#10;    }&#10;&#10;    #[test]&#10;    fn test_include_git_directory() {&#10;        let test_dir = setup_test_dir();&#10;        let mut walker = FileWalker::new(&amp;test_dir);&#10;        walker.include_git(true);&#10;        &#10;        let entries = walker.walk(&amp;test_dir).expect(&quot;遍历失败&quot;);&#10;        let paths: Vec&lt;String&gt; = entries.iter()&#10;            .map(|e| e.path().strip_prefix(&amp;test_dir).unwrap().to_string_lossy().to_string())&#10;            .collect();&#10;        &#10;        // 应该包含 .git 目录下的文件&#10;        assert!(paths.iter().any(|p| p.starts_with(&quot;.git/&quot;)));&#10;        &#10;        // 清理&#10;        fs::remove_dir_all(&amp;test_dir).ok();&#10;    }&#10;&#10;    #[test]&#10;    fn test_wildcard_matching() {&#10;        let test_dir = setup_test_dir();&#10;        &#10;        // 创建一些日志文件&#10;        fs::write(test_dir.join(&quot;app.log&quot;), &quot;log content&quot;).expect(&quot;无法创建日志文件&quot;);&#10;        fs::write(test_dir.join(&quot;debug.log&quot;), &quot;debug content&quot;).expect(&quot;无法创建调试日志&quot;);&#10;        &#10;        let walker = FileWalker::new(&amp;test_dir);&#10;        let entries = walker.walk(&amp;test_dir).expect(&quot;遍历失败&quot;);&#10;        let paths: Vec&lt;String&gt; = entries.iter()&#10;            .map(|e| e.path().strip_prefix(&amp;test_dir).unwrap().to_string_lossy().to_string())&#10;            .collect();&#10;        &#10;        // *.log 文件应该被忽略&#10;        assert!(!paths.iter().any(|p| p.ends_with(&quot;.log&quot;)));&#10;        &#10;        // 清理&#10;        fs::remove_dir_all(&amp;test_dir).ok();&#10;    }&#10;&#10;    #[test]&#10;    fn test_copy_files() {&#10;        let test_dir = setup_test_dir();&#10;        let dest_dir = std::env::temp_dir().join(&quot;idea_backup_test_dest&quot;);&#10;        &#10;        if dest_dir.exists() {&#10;            fs::remove_dir_all(&amp;dest_dir).ok();&#10;        }&#10;        &#10;        let walker = FileWalker::new(&amp;test_dir);&#10;        let file_count = walker.copy_files_to(&amp;test_dir, &amp;dest_dir).expect(&quot;复制失败&quot;);&#10;        &#10;        assert!(file_count &gt; 0);&#10;        assert!(dest_dir.join(&quot;Cargo.toml&quot;).exists());&#10;        assert!(dest_dir.join(&quot;src/main.rs&quot;).exists());&#10;        &#10;        // 清理&#10;        fs::remove_dir_all(&amp;test_dir).ok();&#10;        fs::remove_dir_all(&amp;dest_dir).ok();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.rs" />
              <option name="originalContent" value="use std::collections::HashMap;&#10;use std::env;&#10;use std::fs;&#10;use std::path::PathBuf;&#10;use std::process::{Command, Stdio};&#10;use std::time::{SystemTime, UNIX_EPOCH};&#10;&#10;use clap::Parser;&#10;use dotenv::dotenv;&#10;use serde::{Deserialize, Serialize};&#10;&#10;mod file_walker;&#10;use file_walker::FileWalker;&#10;&#10;#[derive(Parser)]&#10;#[command(name = &quot;idea-backup&quot;)]&#10;#[command(about = &quot;A CLI tool to backup IdeaProjects with 7z compression&quot;)]&#10;struct Args {&#10;    /// Password for 7z compression (overrides .env file)&#10;    #[arg(short, long)]&#10;    password: Option&lt;String&gt;,&#10;&#10;    /// Output directory for backup files&#10;    #[arg(short, long)]&#10;    output: Option&lt;PathBuf&gt;,&#10;&#10;    /// Input directory to scan for projects&#10;    #[arg(short, long, default_value = &quot;~/IdeaProjects&quot;)]&#10;    input: String,&#10;&#10;    /// Force backup even if no changes detected&#10;    #[arg(short, long)]&#10;    force: bool,&#10;}&#10;&#10;/// 项目快照信息&#10;#[derive(Serialize, Deserialize, Debug)]&#10;struct ProjectSnapshot {&#10;    /// 项目路径&#10;    path: String,&#10;    /// 最后修改时间（Unix 时间戳）&#10;    last_modified: u64,&#10;    /// 最后备份时间&#10;    last_backup: u64,&#10;}&#10;&#10;/// 快照管理器&#10;#[derive(Serialize, Deserialize, Debug)]&#10;struct SnapshotManager {&#10;    projects: HashMap&lt;String, ProjectSnapshot&gt;,&#10;}&#10;&#10;/// 扩展路径，处理 ~ 和 . 字符&#10;fn expand_path(path: &amp;str) -&gt; PathBuf {&#10;    let path = if path.starts_with(&quot;~/&quot;) {&#10;        dirs::home_dir().expect(&quot;无法获取home目录&quot;).join(&amp;path[2..])&#10;    } else if path == &quot;~&quot; {&#10;        dirs::home_dir().expect(&quot;无法获取home目录&quot;)&#10;    } else if path.starts_with(&quot;./&quot;) {&#10;        env::current_dir()&#10;            .expect(&quot;无法获取当前目录&quot;)&#10;            .join(&amp;path[2..])&#10;    } else if path == &quot;.&quot; {&#10;        env::current_dir().expect(&quot;无法获取当前目录&quot;)&#10;    } else {&#10;        PathBuf::from(path)&#10;    };&#10;&#10;    // 规范化路径&#10;    path.canonicalize().unwrap_or(path)&#10;}&#10;&#10;fn ensure_7z_installed() {&#10;    let output = Command::new(&quot;which&quot;)&#10;        .arg(&quot;7z&quot;)&#10;        .output()&#10;        .expect(&quot;failed to execute process&quot;);&#10;    if output.status.success() {&#10;        println!(&quot;7z 已安装&quot;);&#10;    } else {&#10;        println!(&quot;正在通过 brew 安装 7z...&quot;);&#10;        let status = Command::new(&quot;brew&quot;)&#10;            .arg(&quot;install&quot;)&#10;            .arg(&quot;p7zip&quot;)&#10;            .status()&#10;            .expect(&quot;failed to install p7zip&quot;);&#10;        if !status.success() {&#10;            panic!(&quot;brew 安装 7z 失败&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;impl SnapshotManager {&#10;    /// 从文件加载快照信息&#10;    fn load(snapshot_file: &amp;PathBuf) -&gt; Self {&#10;        if snapshot_file.exists() {&#10;            match fs::read_to_string(snapshot_file) {&#10;                Ok(content) =&gt; match serde_json::from_str(&amp;content) {&#10;                    Ok(manager) =&gt; manager,&#10;                    Err(e) =&gt; {&#10;                        eprintln!(&quot;解析快照文件失败: {}&quot;, e);&#10;                        Self::new()&#10;                    }&#10;                },&#10;                Err(e) =&gt; {&#10;                    eprintln!(&quot;读取快照文件失败: {}&quot;, e);&#10;                    Self::new()&#10;                }&#10;            }&#10;        } else {&#10;            Self::new()&#10;        }&#10;    }&#10;&#10;    /// 创建新的快照管理器&#10;    fn new() -&gt; Self {&#10;        Self {&#10;            projects: HashMap::new(),&#10;        }&#10;    }&#10;&#10;    /// 保存快照信息到文件&#10;    fn save(&amp;self, snapshot_file: &amp;PathBuf) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let content = serde_json::to_string_pretty(self)?;&#10;        fs::write(snapshot_file, content)?;&#10;        Ok(())&#10;    }&#10;&#10;    /// 更新项目快照信息&#10;    fn update_project(&amp;mut self, project_name: String, path: String, last_modified: u64) {&#10;        let current_time = SystemTime::now()&#10;            .duration_since(UNIX_EPOCH)&#10;            .expect(&quot;时间错误&quot;)&#10;            .as_secs();&#10;&#10;        self.projects.insert(&#10;            project_name,&#10;            ProjectSnapshot {&#10;                path,&#10;                last_modified,&#10;                last_backup: current_time,&#10;            },&#10;        );&#10;    }&#10;}&#10;&#10;/// 获取目录中最新的修改时间&#10;fn get_latest_modification_time(path: &amp;PathBuf) -&gt; Result&lt;u64, Box&lt;dyn std::error::Error&gt;&gt; {&#10;    let walker = FileWalker::new(path).include_hidden(true).include_git(true); // 包含 .git 目录&#10;&#10;    walker.get_latest_modification_time(path)&#10;}&#10;&#10;/// 检查目录是否有文件在指定时间之后被修改&#10;fn has_modifications_after(&#10;    path: &amp;PathBuf,&#10;    after_timestamp: u64,&#10;) -&gt; Result&lt;bool, Box&lt;dyn std::error::Error&gt;&gt; {&#10;    let walker = FileWalker::new(path).include_hidden(true).include_git(true); // 包含 .git 目录&#10;&#10;    walker.has_modifications_after(path, after_timestamp)&#10;}&#10;&#10;fn main() {&#10;    let args = Args::parse();&#10;&#10;    dotenv().ok();&#10;    ensure_7z_installed();&#10;&#10;    // 获取密码：优先使用命令行参数，其次使用环境变量&#10;    let password = args&#10;        .password&#10;        .or_else(|| env::var(&quot;ZIP_PASSWORD&quot;).ok())&#10;        .expect(&quot;请通过 -p 参数或在.env中设置ZIP_PASSWORD&quot;);&#10;&#10;    // 扩展输入目录路径&#10;    let input_dir = expand_path(&amp;args.input);&#10;    println!(&quot;输入目录: {}&quot;, input_dir.display());&#10;&#10;    // 检查输入目录是否存在&#10;    if !input_dir.exists() {&#10;        eprintln!(&quot;错误: 输入目录不存在: {}&quot;, input_dir.display());&#10;        std::process::exit(1);&#10;    }&#10;&#10;    // 获取输出目录：优先使用命令行参数，其次使用默认的 ~/IdeaProjects&#10;    let output_dir = args.output.unwrap_or_else(|| {&#10;        dirs::home_dir()&#10;            .expect(&quot;无法获取home目录&quot;)&#10;            .join(&quot;IdeaProjects&quot;)&#10;    });&#10;&#10;    // 创建输出目录（如果不存在）&#10;    if !output_dir.exists() {&#10;        fs::create_dir_all(&amp;output_dir).expect(&quot;无法创建输出目录&quot;);&#10;        println!(&quot;已创建输出目录: {}&quot;, output_dir.display());&#10;    }&#10;&#10;    // 快照文件路径&#10;    let snapshot_file = output_dir.join(&quot;.backup_snapshots.json&quot;);&#10;&#10;    // 加载快照管理器&#10;    let mut snapshot_manager = SnapshotManager::load(&amp;snapshot_file);&#10;    println!(&#10;        &quot;已加载快照信息，当前跟踪 {} 个项目&quot;,&#10;        snapshot_manager.projects.len()&#10;    );&#10;&#10;    let mut processed_count = 0;&#10;    let mut backed_up_count = 0;&#10;&#10;    for entry in fs::read_dir(&amp;input_dir).unwrap_or_else(|e| {&#10;        eprintln!(&quot;无法读取输入目录 {}: {}&quot;, input_dir.display(), e);&#10;        std::process::exit(1);&#10;    }) {&#10;        let entry = entry.expect(&quot;读取目录项失败&quot;);&#10;        let path = entry.path();&#10;        if path.is_dir() {&#10;            let project_name = path.file_name().unwrap().to_string_lossy().to_string();&#10;            processed_count += 1;&#10;&#10;            println!(&quot;正在检查项目: {}&quot;, project_name);&#10;&#10;            // 先检查快照，如果强制备份则跳过检查&#10;            if !args.force {&#10;                if let Some(snapshot) = snapshot_manager.projects.get(&amp;project_name) {&#10;                    // 快速检查是否有文件在上次备份后被修改&#10;                    match has_modifications_after(&amp;path, snapshot.last_modified) {&#10;                        Ok(false) =&gt; {&#10;                            println!(&quot;  跳过 {} - 无更改&quot;, project_name);&#10;                            continue;&#10;                        }&#10;                        Ok(true) =&gt; {&#10;                            println!(&quot;  检测到 {} 有更改，准备备份&quot;, project_name);&#10;                        }&#10;                        Err(e) =&gt; {&#10;                            eprintln!(&quot;检查项目 {} 修改状态失败: {}&quot;, project_name, e);&#10;                            continue;&#10;                        }&#10;                    }&#10;                } else {&#10;                    println!(&quot;  {} 是新项目，准备首次备份&quot;, project_name);&#10;                }&#10;            } else {&#10;                println!(&quot;  强制备份 {}&quot;, project_name);&#10;            }&#10;&#10;            // 只有确定需要备份时才获取精确的最新修改时间&#10;            let latest_modified = match get_latest_modification_time(&amp;path) {&#10;                Ok(time) =&gt; time,&#10;                Err(e) =&gt; {&#10;                    eprintln!(&quot;获取项目 {} 修改时间失败: {}&quot;, project_name, e);&#10;                    continue;&#10;                }&#10;            };&#10;&#10;            backed_up_count += 1;&#10;&#10;            let backup_name = format!(&quot;{}_backup.7z&quot;, project_name);&#10;            let backup_path = output_dir.join(&amp;backup_name);&#10;&#10;            // 创建临时目录&#10;            let temp_dir = std::env::temp_dir().join(format!(&quot;backup_{}&quot;, project_name));&#10;            if temp_dir.exists() {&#10;                let _ = fs::remove_dir_all(&amp;temp_dir);&#10;            }&#10;            fs::create_dir_all(&amp;temp_dir).expect(&quot;无法创建临时目录&quot;);&#10;&#10;            // 使用FileWalker复制文件到临时目录&#10;            let walker = FileWalker::new(&amp;path)&#10;                .include_hidden(true)&#10;                .include_git(true); // 包含 .git 目录&#10;&#10;            let file_count = match walker.copy_files_to(&amp;path, &amp;temp_dir) {&#10;                Ok(count) =&gt; count,&#10;                Err(e) =&gt; {&#10;                    eprintln!(&quot;复制文件失败: {}&quot;, e);&#10;                    // 清理临时目录&#10;                    let _ = fs::remove_dir_all(&amp;temp_dir);&#10;                    continue;&#10;                }&#10;            };&#10;&#10;            println!(&quot;  已复制 {} 个文件到临时目录&quot;, file_count);&#10;&#10;            // 使用7z压缩临时目录&#10;            let status = Command::new(&quot;7z&quot;)&#10;                .arg(&quot;a&quot;)&#10;                .arg(&amp;backup_path)&#10;                .arg(format!(&quot;-p{}&quot;, password))&#10;                .arg(&quot;-mhe=on&quot;)&#10;                .arg(&quot;-r&quot;)&#10;                .arg(&quot;.&quot;)&#10;                .current_dir(&amp;temp_dir)&#10;                .stdout(Stdio::null())&#10;                .stderr(Stdio::null())&#10;                .status()&#10;                .expect(&quot;7z压缩失败&quot;);&#10;&#10;            // 清理临时目录&#10;            let _ = fs::remove_dir_all(&amp;temp_dir);&#10;&#10;            if status.success() {&#10;                // 更新快照信息&#10;                snapshot_manager.update_project(&#10;                    project_name.clone(),&#10;                    path.to_string_lossy().to_string(),&#10;                    latest_modified,&#10;                );&#10;                println!(&quot;  {} 备份完成: {}&quot;, project_name, backup_path.display());&#10;            } else {&#10;                eprintln!(&quot;  {} 备份失败&quot;, project_name);&#10;            }&#10;        }&#10;    }&#10;&#10;    // 保存快照信息&#10;    if let Err(e) = snapshot_manager.save(&amp;snapshot_file) {&#10;        eprintln!(&quot;保存快照信息失败: {}&quot;, e);&#10;    } else {&#10;        println!(&quot;快照信息已保存到: {}&quot;, snapshot_file.display());&#10;    }&#10;&#10;    println!(&quot;\n备份统计:&quot;);&#10;    println!(&quot;  检查的项目: {}&quot;, processed_count);&#10;    println!(&quot;  执行备份的项目: {}&quot;, backed_up_count);&#10;    println!(&quot;  跳过的项目: {}&quot;, processed_count - backed_up_count);&#10;}&#10;" />
              <option name="updatedContent" value="use std::collections::HashMap;&#10;use std::env;&#10;use std::fs;&#10;use std::path::PathBuf;&#10;use std::process::{Command, Stdio};&#10;use std::time::{SystemTime, UNIX_EPOCH};&#10;&#10;use clap::Parser;&#10;use dotenv::dotenv;&#10;use serde::{Deserialize, Serialize};&#10;&#10;mod file_walker;&#10;use file_walker::FileWalker;&#10;&#10;#[derive(Parser)]&#10;#[command(name = &quot;idea-backup&quot;)]&#10;#[command(about = &quot;A CLI tool to backup IdeaProjects with 7z compression&quot;)]&#10;struct Args {&#10;    /// Password for 7z compression (overrides .env file)&#10;    #[arg(short, long)]&#10;    password: Option&lt;String&gt;,&#10;&#10;    /// Output directory for backup files&#10;    #[arg(short, long)]&#10;    output: Option&lt;PathBuf&gt;,&#10;&#10;    /// Input directory to scan for projects&#10;    #[arg(short, long, default_value = &quot;~/IdeaProjects&quot;)]&#10;    input: String,&#10;&#10;    /// Force backup even if no changes detected&#10;    #[arg(short, long)]&#10;    force: bool,&#10;}&#10;&#10;/// 项目快照信息&#10;#[derive(Serialize, Deserialize, Debug)]&#10;struct ProjectSnapshot {&#10;    /// 项目路径&#10;    path: String,&#10;    /// 最后修改时间（Unix 时间戳）&#10;    last_modified: u64,&#10;    /// 最后备份时间&#10;    last_backup: u64,&#10;}&#10;&#10;/// 快照管理器&#10;#[derive(Serialize, Deserialize, Debug)]&#10;struct SnapshotManager {&#10;    projects: HashMap&lt;String, ProjectSnapshot&gt;,&#10;}&#10;&#10;/// 扩展路径，处理 ~ 和 . 字符&#10;fn expand_path(path: &amp;str) -&gt; PathBuf {&#10;    let path = if path.starts_with(&quot;~/&quot;) {&#10;        dirs::home_dir().expect(&quot;无法获取home目录&quot;).join(&amp;path[2..])&#10;    } else if path == &quot;~&quot; {&#10;        dirs::home_dir().expect(&quot;无法获取home目录&quot;)&#10;    } else if path.starts_with(&quot;./&quot;) {&#10;        env::current_dir()&#10;            .expect(&quot;无法获取当前目录&quot;)&#10;            .join(&amp;path[2..])&#10;    } else if path == &quot;.&quot; {&#10;        env::current_dir().expect(&quot;无法获取当前目录&quot;)&#10;    } else {&#10;        PathBuf::from(path)&#10;    };&#10;&#10;    // 规范化路径&#10;    path.canonicalize().unwrap_or(path)&#10;}&#10;&#10;fn ensure_7z_installed() {&#10;    let output = Command::new(&quot;which&quot;)&#10;        .arg(&quot;7z&quot;)&#10;        .output()&#10;        .expect(&quot;failed to execute process&quot;);&#10;    if output.status.success() {&#10;        println!(&quot;7z 已安装&quot;);&#10;    } else {&#10;        println!(&quot;正在通过 brew 安装 7z...&quot;);&#10;        let status = Command::new(&quot;brew&quot;)&#10;            .arg(&quot;install&quot;)&#10;            .arg(&quot;p7zip&quot;)&#10;            .status()&#10;            .expect(&quot;failed to install p7zip&quot;);&#10;        if !status.success() {&#10;            panic!(&quot;brew 安装 7z 失败&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;impl SnapshotManager {&#10;    /// 从文件加载快照信息&#10;    fn load(snapshot_file: &amp;PathBuf) -&gt; Self {&#10;        if snapshot_file.exists() {&#10;            match fs::read_to_string(snapshot_file) {&#10;                Ok(content) =&gt; match serde_json::from_str(&amp;content) {&#10;                    Ok(manager) =&gt; manager,&#10;                    Err(e) =&gt; {&#10;                        eprintln!(&quot;解析快照文件失败: {}&quot;, e);&#10;                        Self::new()&#10;                    }&#10;                },&#10;                Err(e) =&gt; {&#10;                    eprintln!(&quot;读取快照文件失败: {}&quot;, e);&#10;                    Self::new()&#10;                }&#10;            }&#10;        } else {&#10;            Self::new()&#10;        }&#10;    }&#10;&#10;    /// 创建新的快照管理器&#10;    fn new() -&gt; Self {&#10;        Self {&#10;            projects: HashMap::new(),&#10;        }&#10;    }&#10;&#10;    /// 保存快照信息到文件&#10;    fn save(&amp;self, snapshot_file: &amp;PathBuf) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let content = serde_json::to_string_pretty(self)?;&#10;        fs::write(snapshot_file, content)?;&#10;        Ok(())&#10;    }&#10;&#10;    /// 更新项目快照信息&#10;    fn update_project(&amp;mut self, project_name: String, path: String, last_modified: u64) {&#10;        let current_time = SystemTime::now()&#10;            .duration_since(UNIX_EPOCH)&#10;            .expect(&quot;时间错误&quot;)&#10;            .as_secs();&#10;&#10;        self.projects.insert(&#10;            project_name,&#10;            ProjectSnapshot {&#10;                path,&#10;                last_modified,&#10;                last_backup: current_time,&#10;            },&#10;        );&#10;    }&#10;}&#10;&#10;/// 获取目录中最新的修改时间&#10;fn get_latest_modification_time(path: &amp;PathBuf) -&gt; Result&lt;u64, Box&lt;dyn std::error::Error&gt;&gt; {&#10;    let walker = FileWalker::new(path).include_hidden(true).include_git(true); // 包含 .git 目录&#10;&#10;    walker.get_latest_modification_time(path)&#10;}&#10;&#10;/// 检查目录是否有文件在指定时间之后被修改&#10;fn has_modifications_after(&#10;    path: &amp;PathBuf,&#10;    after_timestamp: u64,&#10;) -&gt; Result&lt;bool, Box&lt;dyn std::error::Error&gt;&gt; {&#10;    let walker = FileWalker::new(path).include_hidden(true).include_git(true); // 包含 .git 目录&#10;&#10;    walker.has_modifications_after(path, after_timestamp)&#10;}&#10;&#10;fn main() {&#10;    let args = Args::parse();&#10;&#10;    dotenv().ok();&#10;    ensure_7z_installed();&#10;&#10;    // 获取密码：优先使用命令行参数，其次使用环境变量&#10;    let password = args&#10;        .password&#10;        .or_else(|| env::var(&quot;ZIP_PASSWORD&quot;).ok())&#10;        .expect(&quot;请通过 -p 参数或在.env中设置ZIP_PASSWORD&quot;);&#10;&#10;    // 扩展输入目录路径&#10;    let input_dir = expand_path(&amp;args.input);&#10;    println!(&quot;输入目录: {}&quot;, input_dir.display());&#10;&#10;    // 检查输入目录是否存在&#10;    if !input_dir.exists() {&#10;        eprintln!(&quot;错误: 输入目录不存在: {}&quot;, input_dir.display());&#10;        std::process::exit(1);&#10;    }&#10;&#10;    // 获取输出目录：优先使用命令行参数，其次使用默认的 ~/IdeaProjects&#10;    let output_dir = args.output.unwrap_or_else(|| {&#10;        dirs::home_dir()&#10;            .expect(&quot;无法获取home目录&quot;)&#10;            .join(&quot;IdeaProjects&quot;)&#10;    });&#10;&#10;    // 创建输出目录（如果不存在）&#10;    if !output_dir.exists() {&#10;        fs::create_dir_all(&amp;output_dir).expect(&quot;无法创建输出目录&quot;);&#10;        println!(&quot;已创建输出目录: {}&quot;, output_dir.display());&#10;    }&#10;&#10;    // 快照文件路径&#10;    let snapshot_file = output_dir.join(&quot;.backup_snapshots.json&quot;);&#10;&#10;    // 加载快照管理器&#10;    let mut snapshot_manager = SnapshotManager::load(&amp;snapshot_file);&#10;    println!(&#10;        &quot;已加载快照信息，当前跟踪 {} 个项目&quot;,&#10;        snapshot_manager.projects.len()&#10;    );&#10;&#10;    let mut processed_count = 0;&#10;    let mut backed_up_count = 0;&#10;&#10;    for entry in fs::read_dir(&amp;input_dir).unwrap_or_else(|e| {&#10;        eprintln!(&quot;无法读取输入目录 {}: {}&quot;, input_dir.display(), e);&#10;        std::process::exit(1);&#10;    }) {&#10;        let entry = entry.expect(&quot;读取目录项失败&quot;);&#10;        let path = entry.path();&#10;        if path.is_dir() {&#10;            let project_name = path.file_name().unwrap().to_string_lossy().to_string();&#10;            processed_count += 1;&#10;&#10;            println!(&quot;正在检查项目: {}&quot;, project_name);&#10;&#10;            // 先检查快照，如果强制备份则跳过检查&#10;            if !args.force {&#10;                if let Some(snapshot) = snapshot_manager.projects.get(&amp;project_name) {&#10;                    // 快速检查是否有文件在上次备份后被修改&#10;                    match has_modifications_after(&amp;path, snapshot.last_modified) {&#10;                        Ok(false) =&gt; {&#10;                            println!(&quot;  跳过 {} - 无更改&quot;, project_name);&#10;                            continue;&#10;                        }&#10;                        Ok(true) =&gt; {&#10;                            println!(&quot;  检测到 {} 有更改，准备备份&quot;, project_name);&#10;                        }&#10;                        Err(e) =&gt; {&#10;                            eprintln!(&quot;检查项目 {} 修改状态失败: {}&quot;, project_name, e);&#10;                            continue;&#10;                        }&#10;                    }&#10;                } else {&#10;                    println!(&quot;  {} 是新项目，准备首次备份&quot;, project_name);&#10;                }&#10;            } else {&#10;                println!(&quot;  强制备份 {}&quot;, project_name);&#10;            }&#10;&#10;            // 只有确定需要备份时才获取精确的最新修改时间&#10;            let latest_modified = match get_latest_modification_time(&amp;path) {&#10;                Ok(time) =&gt; time,&#10;                Err(e) =&gt; {&#10;                    eprintln!(&quot;获取项目 {} 修改时间失败: {}&quot;, project_name, e);&#10;                    continue;&#10;                }&#10;            };&#10;&#10;            backed_up_count += 1;&#10;&#10;            let backup_name = format!(&quot;{}_backup.7z&quot;, project_name);&#10;            let backup_path = output_dir.join(&amp;backup_name);&#10;&#10;            // 创建临时目录&#10;            let temp_dir = std::env::temp_dir().join(format!(&quot;backup_{}&quot;, project_name));&#10;            if temp_dir.exists() {&#10;                let _ = fs::remove_dir_all(&amp;temp_dir);&#10;            }&#10;            fs::create_dir_all(&amp;temp_dir).expect(&quot;无法创建临时目录&quot;);&#10;&#10;            // 使用FileWalker复制文件到临时目录&#10;            let walker = FileWalker::new(&amp;path)&#10;                .include_hidden(true)&#10;                .include_git(true); // 包含 .git 目录&#10;&#10;            let file_count = match walker.copy_files_to(&amp;path, &amp;temp_dir) {&#10;                Ok(count) =&gt; count,&#10;                Err(e) =&gt; {&#10;                    eprintln!(&quot;复制文件失败: {}&quot;, e);&#10;                    // 清理临时目录&#10;                    let _ = fs::remove_dir_all(&amp;temp_dir);&#10;                    continue;&#10;                }&#10;            };&#10;&#10;            println!(&quot;  已复制 {} 个文件到临时目录&quot;, file_count);&#10;&#10;            // 使用7z压缩临时目录&#10;            let status = Command::new(&quot;7z&quot;)&#10;                .arg(&quot;a&quot;)&#10;                .arg(&amp;backup_path)&#10;                .arg(format!(&quot;-p{}&quot;, password))&#10;                .arg(&quot;-mhe=on&quot;)&#10;                .arg(&quot;-r&quot;)&#10;                .arg(&quot;.&quot;)&#10;                .current_dir(&amp;temp_dir)&#10;                .stdout(Stdio::null())&#10;                .stderr(Stdio::null())&#10;                .status()&#10;                .expect(&quot;7z压缩失败&quot;);&#10;&#10;            // 清理临时目录&#10;            let _ = fs::remove_dir_all(&amp;temp_dir);&#10;&#10;            if status.success() {&#10;                // 更新快照信息&#10;                snapshot_manager.update_project(&#10;                    project_name.clone(),&#10;                    path.to_string_lossy().to_string(),&#10;                    latest_modified,&#10;                );&#10;                println!(&quot;  {} 备份完成: {}&quot;, project_name, backup_path.display());&#10;            } else {&#10;                eprintln!(&quot;  {} 备份失败&quot;, project_name);&#10;            }&#10;        }&#10;    }&#10;&#10;    // 保存快照信息&#10;    if let Err(e) = snapshot_manager.save(&amp;snapshot_file) {&#10;        eprintln!(&quot;保存快照信息失败: {}&quot;, e);&#10;    } else {&#10;        println!(&quot;快照信息已保存到: {}&quot;, snapshot_file.display());&#10;    }&#10;&#10;    println!(&quot;\n备份统计:&quot;);&#10;    println!(&quot;  检查的项目: {}&quot;, processed_count);&#10;    println!(&quot;  执行备份的项目: {}&quot;, backed_up_count);&#10;    println!(&quot;  跳过的项目: {}&quot;, processed_count - backed_up_count);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>